# Documentación para instalar y configurar Channels en la API DRF## Local (Windows): ### Requerimientos:Se debe instalar y correr [Redis](https://redis.io/)Para instalar en Windows, no existe versión oficial pero hay un port en github en este [link](https://github.com/MicrosoftArchive/redis)Puedes descargar e instalar el binario .MSI que se encuentra en [release page.](https://github.com/MicrosoftArchive/redis/releases)### Instalación:Se deben agregar al requirements.txt de la API los siguientes paquetes de Python con sus versiones especificas:* channels==1.1.8* daphne==1.3.0* redis==2.10.6* asgi-redis==1.4.3* asgiref==1.1.2* Twisted==17.9.0* Twisted[tls,http2]==17.9.0y ejecutar el comando:    pip install -r requirements.txtdebe verificarse que se han instalado los paquetes. es  posible que falle el paquete Twisted[tls,http2]si es así debe ejecutarse  el comando pip install Twisted[tls,http2](Sola para Windows, correr el siguiente comando por la terminal)    pip install pypiwin32==219 (Solo para Windows)    Se debe agregar channels a las apps instaladas en Django:    INSTALLED_APPS = (           'django.contrib.auth',        'django.contrib.contenttypes',        'django.contrib.sessions',        'django.contrib.sites',        'channels',    ) Una vez habilitado debería de integrarse asi misma con Django y tomar control del comando  `runserver`### Configuración####Channel LayerEn el `settings.py` de la aplicación en django debe crearse una capa de channels de las siguiente manera:      CHANNEL_LAYERS = {        "default": {          "BACKEND": "asgi_redis.RedisChannelLayer",        "CONFIG": {            "hosts": [os.environ.get('REDIS_URL', 'redis://localhost:6379')],        },        "ROUTING": "myapp.routing.channel_routing",  # myapp es la app de django donde esta configurado channels       },    }Verificar que el puerto configurado en redis, en este caso (6379) no este siendo usado por otra aplicación.Este es el mecanismo de transporte que usa Channels para pasar mensajes de los productores (remitentes de mensajes) a los consumidores. Es un tipo de cola de mensajes con algunas propiedades específicas (ver la [documentación](http://channels.readthedocs.io/en/1.x/concepts.html#what-is-a-channel) de Channels para más detalles).Como se ve, se utiliza Redis para nuestra capa de canal: es la capa de canal de calidad de producción preferida. Para más detalles, consulte nuevamente la [documentación](http://channels.readthedocs.io/en/1.x/backends.html)####RoutingEn CHANNEL_LAYERS, le indicamos a Channel dónde buscar el enrutamiento de nuestro canal: `myapp.routing.channel_routing`. El enrutamiento de canales es un concepto muy similar al enrutamiento de URL: el enrutamiento de URL mapea las URL para ver las funciones; el enrutamiento del canal asigna los canales a las funciones del consumidor. También similar a urls.py, por convención las rutas de los canales viven en un `routing.py`.Creamos el archivo dentro de `myapp` e ingresamos el siguiente codigo:    from . import consumers    channel_routing = {    # Wire up websocket channels to our consumers:    'websocket.connect': consumers.ws_connect,    'websocket.receive': consumers.ws_receive,    'websocket.disconnect': consumers.ws_disconnect,    }Nuestro `consumers.py` se crea en la misma carpeta y debe configurarse anclándose con el channel_routing    from channels import Group	from channels.sessions import channel_session	from .models import Room	import json	@channel_session	def ws_connect(message):        message.reply_channel.send({"accept": True})        ...	@channel_session	def ws_receive(message):	   ...	@channel_session	def ws_disconnect(message):	   ...####Correr con canalesFinalmente, debemos cambiar el manejador de solicitudes basado en HTTP / WSGI de Django, por el integrado en los canales. Esto se basa en un estándar emergente llamado ASGI (Asynchronous Server Gateway), por lo que definiremos ese controlador en un archivo `asgi.py` que se debe crear en `myapp`:	import os	import django	from channels.asgi import get_channel_layer	os.environ.setdefault("DJANGO_SETTINGS_MODULE", "myproject.settings") # myproject cambiarlo por mi proyecto actual en django	channel_layer = get_channel_layer()A este punto ya estaría disponible para correr con `python manage.py runserver`cuando se corre en una consola veras una información parecída a esta    2018-03-13 09:07:22,050 - INFO - worker - Listening on channels http.request, websocket.connect, websocket.disconnect, websocket.receive	2018-03-13 09:07:22,058 - INFO - worker - Listening on channels http.request, websocket.connect, websocket.disconnect, websocket.receive	2018-03-13 09:07:22,059 - INFO - worker - Listening on channels http.request, websocket.connect, websocket.disconnect, websocket.receive	2018-03-13 09:07:22,062 - INFO - worker - Listening on channels http.request, websocket.connect, websocket.disconnect, websocket.receive	2018-03-13 09:07:22,064 - INFO - server - HTTP/2 support enabled	2018-03-13 09:07:22,066 - INFO - server - Using busy-loop synchronous mode on channel layer	2018-03-13 09:07:22,067 - INFO - server - Listening on endpoint tcp:port=8000:interface=127.0.0.1de esta  manera se verifica que funciona correctamente channels y ya esta abierto para aceptar conexiones con un cliente socket.## Producción (Ubuntu Server)#### RequerimientosSe debe instalar redis, se puede hacer directamente desde los repositorioso desde la pagina oficial. se puede seguir este [tutorial](https://www.comoinstalarlinux.com/como-instalar-redis-en-ubuntu-16-04/)y debe configurarse como servicio (demonio) usando systemd.Ademas para correr en segundo plano deben configurarse tanto Daphne como el runworker como demonios. en este ejemplo se hara en systemdnos ubicamos en la ruta `cd /etc/systemd/system` luego creamos un archivo con extensión .service. para Daphne`sudo nano daphne.service`	[Unit]	Description=daphne server	After=network.target	[Service]	User=www-data	Group=www-data	WorkingDirectory=/path/to/working/directory	ExecStart=/home/ubuntu/dev/virtualenv/bin/daphne -b 0.0.0.0 -p 80	myapp.asgi:channel_layer	Restart=always	[Install]	WantedBy=multi-user.targeten User y Group, colocaremos el usuario y grupo web que queremos que corra la aplicación.WorkingDirectory, es el directorio donde se encuentra nuestra aplicación. ExecStart, es el comando para ejecutar Daphne, lo primero es colocar la ruta absoluta donde se encuentra el archivo Daphne. el argumento -b es la ip, en este caso como queremos que sea en red. lo corremos 0.0.0.0. el argumento -p será el puerto con el que queremos que se escuche la aplicación. luego en "myapp.asgi:channel_layer", es la app asgi donde nuestro proyecto ha configurado la capa de cannel.(Ojo todas las rutas deben ser rutas absolutas)Restart=always, le diremos que siempre reinicie el servidor cuando encuentre problemasy luego creamos el archivo de runworker.service para correr el worker`sudo nano runworker.service`    [Unit]    Description=python runworker server    After=network.target    [Service]    User=www-data    Group=www-data    WorkingDirectory=/home/ubuntu/dev/linkupbackedweb    ExecStart=/home/ubuntu/dev/envweb/bin/python3   /home/ubuntu/dev/linkupbackedweb/manage.py runworker --threads 2    Restart=always    [Install]    WantedBy=multi-user.targetpara habilitarlos como servicios de systemd:      sudo systemctl enable daphne      sudo systemctl enable runworkerpara verificar que están corriendo correctamente puedes probar:    sudo systemctl status daphne      sudo systemctl status runworkerCon esto ya debería de estar corriendo el socket.    se puede probar el socket y su comunicación con un cliente js. con la siguiente estructura:	$(function() {    // When we're using HTTPS, use WSS too.    var ws_scheme = window.location.protocol == "http:" ? "wss" : "ws";    var api_url = "127.0.0.1:80"  //el dominio o ip a donde esta nuestro proyecto de socket funcionando  	var chatsock = new ReconnectingWebSocket("ws" + '://' + api_url + "/chat" + window.location.pathname);    chatsock.onopen = function open() {     console.log('WebSockets connection created.');   };    chatsock.onmessage = function(message) {        var data = JSON.parse(message.data);        var chat = $("#chat")        var ele = $('<tr></tr>')        ele.append(            $("<td></td>").text(data.timestamp)        )        ele.append(            $("<td></td>").text(data.handle)        )        ele.append(            $("<td></td>").text(data.message)        )        chat.append(ele)    };    $("#chatform").on("submit", function(event) {        var message = {            handle: $('#handle').val(),            message: $('#message').val(),        }        chatsock.send(JSON.stringify(message));        $("#message").val('').focus();        return false;    });    if (chatsock.readyState == WebSocket.OPEN) {     chatsock.onopen();   }});
